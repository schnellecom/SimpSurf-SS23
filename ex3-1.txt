LoadPackage("SimplicialSurface");;

#can apparently also be done with Reversed(list);
ReverseList:=function(list)
	local i, res;
	res := [];
	for i in [0..Length(list)-1] do
		if IsBound(list[Length(list)-i]) then
			Add(res, list[Length(list)-i]);
		fi;
	od;
	return res;
end;

InterateList:=function(list)
	local i, res;
	res := [];
	res[1] := list[Length(list)];
	for i in [2..Length(list)] do
		if IsBound(list[i-1]) then
			Add(res, list[i-1]);
		fi;
	od;
	return res;
end;

AllSimplexRings:=function(n)
	local i, partitions, dyclets, part, sigma, d, e, simplexRings, umbrellaDesc, counter, a, tmp, u, pos;
	partitions := Partitions(n);
#	dyclets := [];
#	for part in partitions do
#		for sigma in SymmetricGroup(Length(part)) do
#			Add(dyclets, Permuted(part, sigma));
#		od;
#	od;
#	Print(dyclets,"\n");
#	for d in dyclets do
#		pos := Position(dyclets, d);
#		for e in dyclets do
#			if ReverseList(d) = e then
#				Remove(dyclets, pos);
#			fi;
#			for i in [1..n] do
#				if InterateList(d) = e then
#					Remove(dyclets, pos);
#				fi;
#				d := InterateList(d);
#			od;
#		od;
#	od;
#	Print(dyclets,"\n");

	simplexRings := [];
	Add(simplexRings, SimplicialUmbrella(n));
	for d in partitions do
		#only partitions of length more than 2 are simplicial surfaces
		if Length(d) > 2 then
			Print("d", d, "\n");
			umbrellaDesc := [];
			
			#add first and last manually
			tmp := [n];
			for i in [1..d[1]+1] do
				Add(tmp, i);;
			od;
			Add(umbrellaDesc, tmp);

			if d[1] > 1 then
				for i in [1..d[1]-1] do
					Add(umbrellaDesc, [i, i+1]);
				od;
			fi;

			tmp := [];
			for i in [n-d[Length(d)]..n] do
				Add(tmp, i);
			od;
			Add(tmp, 1);
			Add(umbrellaDesc, tmp);

			if d[Length(d)] > 1 then
				for i in [n-d[Length(d)]+1..n-1] do
					Add(umbrellaDesc, [i, i+1]);
				od;
			fi;

			counter := d[1];
			#remove first and last to add directly, to give the modulo
			Remove(d, Length(d));
			Remove(d, 1);
			for a in d do
				tmp := [];
				for u in [counter..counter+a+1] do
					Add(tmp, u);
				od;
				Add(umbrellaDesc, tmp);
				tmp := [];
				if a > 1 then
					for u in [counter+1..counter+a-1] do
						Add(umbrellaDesc, [u, u+1]);
					od;
				fi;
				counter := counter+a;
			od;
			Add(simplexRings, SimplicialSurfaceByUmbrellaDescriptor(umbrellaDesc));
		fi;
	od;
	return simplexRings;
end;